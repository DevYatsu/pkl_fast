file = { SOI ~ stmt* ~ EOI}

stmt = { typealias | module | import | extends | amends | function | property_stmt | expr }
expr = { (WHITESPACE|COMMENT)* ~ (dot_expr | value | fn_call | ident | amended_object) }

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
SPACE = _{ " " | "\t" }

END_NEWLINE = @{(SPACE | COMMENT)* ~ "\n"}

line_comment = { "//" ~ (!"\n" ~ ANY)* }
doc_comment = { "///" ~ (!"\n" ~ ANY)* }
multiline_comment = { "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
COMMENT = _{ line_comment | doc_comment | multiline_comment }


// ********
//  *****
//  exprs
//  *****
// ********

ident_with_start_symbol = { ("_" | "$") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")+ }
ident_without_start_symbol = { ASCII_ALPHA+ ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }
basic_ident = @{ ident_without_start_symbol | ident_with_start_symbol }
illegal_ident = { "`" ~ (!"`" ~ ANY)+ ~ "`" }
// blank_ident = { _ }
ident = @{ basic_ident | illegal_ident }

fn_call = { ident ~ "(" ~ (expr ~ ("," ~ expr)* ~ ","?)? ~ ")"}
dot_expr = { (value | fn_call | ident) ~ ("." ~ (fn_call | ident))+ }

value = { bool | null | float | int | string }

null = _{ "null" }
bool = @{ "true" | "false" }

// Strings
unicode_digits = @{  ASCII_HEX_DIGIT{1, 6}  }
escape_sequences = {"\\t" | "\\n" | "\\r" | "\\\"" | "\\\\" | ("\\u" ~ "{" ~ unicode_digits ~ "}") }

interpolation = { "\\(" ~ expr ~ ")"  }

basic_string_true_content = { (!"\"" ~ (interpolation | escape_sequences | ANY))* }
basic_string = {"\"" ~ basic_string_true_content ~ "\""}


multiline_content = { (!multiline_end ~ (interpolation | escape_sequences | ANY))* }
multiline_end = { "\n" ~ SPACE* ~ "\"\"\"" }
multiline_start = { "\"\"\"" ~ SPACE? ~ "\n" }
multiline_string = { multiline_start ~ multiline_content ~ multiline_end}

custom_escaped = @{ "\\#" | escape_sequences }
custom_string = {
    PUSH("#"*) ~ "\""
        ~ raw_string_interior
        ~ "\"" ~ POP
}
raw_string_interior = {
    (
        !("\"" ~ PEEK)    // unless the next character is a quotation mark
                          // followed by the correct amount of number signs,
                          // consume content
        ~ (interpolation | custom_escaped | ANY)
    )*
}

string = { multiline_string | basic_string | custom_string }

// Numbers
hex_int = @{ "0x" ~ ASCII_HEX_DIGIT+ ~ ("_" ~ ASCII_HEX_DIGIT+)* }
octal_int = @{ "0o" ~ ASCII_OCT_DIGIT+ ~ ("_" ~ ASCII_OCT_DIGIT+)* }
binary_int = @{  "0b" ~ ASCII_BIN_DIGIT+ ~ ("_" ~ ASCII_BIN_DIGIT+)* }
basic_int = @ { ASCII_DIGIT+ ~ ("_" ~ ASCII_DIGIT+)* }
int = { "-"? ~ (hex_int | octal_int | binary_int | basic_int) }

exponent = { ("e" | "E") ~ ("+" | "-")? ~ basic_int+ }
float = @{ "NaN" | ("-"? ~ ("Infinity" | (basic_int? ~ "." ~ basic_int+ ~ exponent? )))}

// do we need to enforce the
// input of a newline after a prop here ?
obj_fields = { property ~ (END_NEWLINE ~ WHITESPACE* ~ property)* }
object = ${ "{" ~ WHITESPACE* ~ obj_fields? ~ WHITESPACE* ~ "}"}

amended_object = { "(" ~ ident ~ ")" ~ WHITESPACE* ~ object }

// ********
//  *****
//  stmts
//  *****
// ********

property_keyword = @{ ("local" | "fixed" | "const") ~ WHITESPACE+}
property = ${ (property_keyword)* ~ ident ~ WHITESPACE* ~ (object | ((":" ~ WHITESPACE* ~ TYPE ~ WHITESPACE*)? ~ "=" ~ WHITESPACE* ~ expr))}
// stmt just has a END_NEWLINE at the end
property_stmt = ${ property ~ END_NEWLINE }

typealias_params = {WHITESPACE* ~ ident ~ (WHITESPACE* ~ "," ~ WHITESPACE* ~ ident)* ~ WHITESPACE* }
typealias = ${ "typealias" ~ WHITESPACE+  ~ ident ~ ("<" ~ typealias_params ~ ">")? ~ WHITESPACE* ~ "=" ~ WHITESPACE* ~ TYPE ~ END_NEWLINE }

module_keyword = @{ ("open" ~ WHITESPACE+)? ~ "module"}
module_src = {ident ~ ("." ~ ident)*}
module = ${ module_keyword ~ WHITESPACE+ ~ module_src ~ END_NEWLINE}

src = {"\"" ~ (!"\"" ~ ANY)+ ~ "\""}

amends = ${ "amends" ~ WHITESPACE+ ~ src ~ END_NEWLINE}
extends = ${ "extends" ~ WHITESPACE+ ~ src ~ END_NEWLINE}

import_as = {ident}
import = ${ "import" ~ WHITESPACE+ ~ src ~ (WHITESPACE+ ~ "as" ~ WHITESPACE+ ~ import_as)? ~ END_NEWLINE }

arg = { ident ~ WHITESPACE* ~ ":" ~ WHITESPACE* ~ TYPE }
function_args = { WHITESPACE* ~ arg ~ (WHITESPACE* ~ "," ~ WHITESPACE* ~ arg)* ~ WHITESPACE* ~ ("," ~ WHITESPACE*)? }
return_type = {TYPE}
function = ${ "function" ~ WHITESPACE+ ~ ident ~ WHITESPACE* ~ "(" ~ function_args? ~  ")" ~ (WHITESPACE* ~ ":" ~ WHITESPACE* ~ return_type)? ~ WHITESPACE* ~ "=" ~ WHITESPACE* ~ expr ~ END_NEWLINE}


// ********
//  *****
//  types
//  *****
// ********

// do not use 'type' cause it's a rust keyword
TYPE = { union | basic_type }

basic_type = {type_with_restraints | type_with_attr | ident}
type_with_attr = { ident ~ "<" ~ TYPE ~ ("," ~ TYPE)* ~ ">"}
type_with_restraints = { (type_with_attr | ident) ~ "(" ~ expr ~ ")"}

union = { basic_type ~ ("|" ~ basic_type)+}
