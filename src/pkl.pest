file = { SOI ~ stmt* ~ EOI}

stmt = { typealias | module | import | extends | amends | function | property | expr }
expr = { dot_expr | value | fn_call | ident }

WHITESPACE = _{ " " | "\t" | "\n" }
SPACE = _{ " " | "\t" }

END_NEWLINE = _{SPACE* ~ !"\n"}

line_comment = { "//" ~ (!"\n" ~ ANY)* }
doc_comment = { "///" ~ (!"\n" ~ ANY)* }
multiline_comment = { "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
COMMENT = _{ line_comment | doc_comment | multiline_comment }


// ********
//  *****
//  exprs
//  *****
// ********

ident_with_start_symbol = { ("_" | "$") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")+ }
ident_without_start_symbol = { ASCII_ALPHA+ ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }
basic_ident = @{ ident_without_start_symbol | ident_with_start_symbol }
illegal_ident = { "`" ~ (!"`" ~ ANY)+ ~ "`" }
// blank_ident = { _ }
ident = @{ basic_ident | illegal_ident }

fn_call = { ident ~ "(" ~ (expr ~ ("," ~ expr)* ~ ","?)? ~ ")"}
dot_expr = { (value | fn_call | ident) ~ ("." ~ (fn_call | ident))+ }

value = { bool | null | float | int | string }

null = _{ "null" }
bool = @{ "true" | "false" }

// Strings
unicode_digits = @{  ASCII_HEX_DIGIT{1, 6}  }
escape_sequences = {"\\t" | "\\n" | "\\r" | "\\\"" | "\\\\" | ("\\u" ~ "{" ~ unicode_digits ~ "}") }

interpolation = { "\\(" ~ expr ~ ")"  }

basic_string_true_content = { (!"\"" ~ (interpolation | escape_sequences | ANY))* }
basic_string = {"\"" ~ basic_string_true_content ~ "\""}


multiline_content = { (!multiline_end ~ (interpolation | escape_sequences | ANY))* }
multiline_end = { "\n" ~ SPACE* ~ "\"\"\"" }
multiline_start = { "\"\"\"" ~ SPACE? ~ "\n" }
multiline_string = { multiline_start ~ multiline_content ~ multiline_end}

custom_escaped = @{ "\\#" | escape_sequences }
custom_string = {
    PUSH("#"*) ~ "\""
        ~ raw_string_interior
        ~ "\"" ~ POP
}
raw_string_interior = {
    (
        !("\"" ~ PEEK)    // unless the next character is a quotation mark
                          // followed by the correct amount of number signs,
                          // consume content
        ~ (interpolation | custom_escaped | ANY)
    )*
}


string = { multiline_string | basic_string | custom_string }


hex_int = @{ "0x" ~ ASCII_HEX_DIGIT+ ~ ("_" ~ ASCII_HEX_DIGIT+)* }
octal_int = @{ "0o" ~ ASCII_OCT_DIGIT+ ~ ("_" ~ ASCII_OCT_DIGIT+)* }
binary_int = @{  "0b" ~ ASCII_BIN_DIGIT+ ~ ("_" ~ ASCII_BIN_DIGIT+)* }
basic_int = @ { ASCII_DIGIT+ ~ ("_" ~ ASCII_DIGIT+)* }
int = { "-"? ~ (hex_int | octal_int | binary_int | basic_int) }

exponent = { ("e" | "E") ~ ("+" | "-")? ~ basic_int+ }
float = @{ "NaN" | ("-"? ~ ("Infinity" | (basic_int? ~ "." ~ basic_int+ ~ exponent? )))}


// ********
//  *****
//  stmts
//  *****
// ********

property_keyword = @{ ("local" | "fixed" | "const") ~ WHITESPACE+}
property = { (property_keyword)* ~ ident ~ (":" ~ TYPE)? ~ "=" ~ expr ~ END_NEWLINE}

typealias_keyword = @{ "typealias" ~ WHITESPACE+}
typealias = { typealias_keyword ~ ident ~ "=" ~ TYPE ~ END_NEWLINE}

module_keyword = @{ ("open" ~ WHITESPACE+)? ~ "module"}
module_src = {ident ~ ("." ~ ident)*}
module = ${ module_keyword ~ WHITESPACE+ ~ module_src}

src = {"\"" ~ (!"\"" ~ ANY)+ ~ "\""}

amends = ${ "amends" ~ WHITESPACE+ ~ src}
extends = ${ "extends" ~ WHITESPACE+ ~ src}

import_as = {ident}
import = ${ "import" ~ WHITESPACE+ ~ src ~ (WHITESPACE+ ~ "as" ~ WHITESPACE+ ~ import_as)? }

function_keyword = @{"function" ~ WHITESPACE+}
arg = {ident ~ ":" ~ TYPE}
function_args = { (arg ~ ("," ~ arg)* ~ ","?)? }
return_type = {TYPE}
function = { function_keyword ~ ident ~ "(" ~ function_args ~  ")" ~ (":" ~ return_type)? ~ "=" ~ expr }


// ********
//  *****
//  types
//  *****
// ********

// do not use 'type' cause it's a rust keyword
TYPE = { union | basic_type }

basic_type = {type_with_restraints | type_with_attr | ident}
type_with_attr = { ident ~ "<" ~ TYPE ~ ("," ~ TYPE)* ~ ">"}
type_with_restraints = { (type_with_attr | ident) ~ "(" ~ expr ~ ")"}

union = { basic_type ~ ("|" ~ basic_type)+}
