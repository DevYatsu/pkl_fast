file = { SOI ~ stmt* ~ EOI}

stmt = { with_annotation | with_doc_comment | typealias | module | import | extends | amends | function | class | property | expr }

KEYWORDS = {"typealias" | "module" | "import" | "extends" | "amends" | "function" | "in" | "let" | "is" |
    "local" | "fixed" | "const" | "hidden" | "open" | "true" | "false" | "null" | "Infinity" | "NaN" |
    "extends" | "abstract" | "class" | "new" | "this"
}

WHITESPACE = _{ " " | "\t" | "\n" | "\r" | ";" }
SPACE = _{ " " | "\t" }

WHITESPACE_COMMENT = {WHITESPACE | COMMENT | ";"}
SPACE_COMMENT = {(SPACE | COMMENT)*}

EQUAL = !{WHITESPACE_COMMENT* ~ "="}
COLON = !{WHITESPACE_COMMENT* ~ ":"}

line_comment = { "//" ~ !"/" ~ (!"\n" ~ ANY)* }
multiline_comment = { "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
COMMENT = _{ line_comment | multiline_comment }


// ********
//  *****
//  exprs
//  *****
// ********

expr = !{ (prefix? ~ primary_expr ~ postfix? ~ ((infix ~ prefix? ~ primary_expr ~ postfix?)|(type_op~TYPE))*) }
primary_expr = { if_else_expr | let_expr | function_expr | listing | class_instance | dot_expr | index_expr | fn_call | ident | value | amended_object | parenthesized }

null_propagation = {(dot_expr | parenthesized | value | fn_call | ident) ~ "?." ~ ident}
parenthesized = !{"(" ~ expr ~ ")"}

condition = {expr}
if_expr = {expr}
else_expr = {expr}
if_else_expr = {"if" ~ "(" ~ condition ~ ")" ~ if_expr ~ "else" ~ else_expr }

let_value = {expr}
let_expr = {"let" ~ "(" ~ ident ~ (COLON ~ TYPE)? ~ EQUAL ~ let_value ~ ")" ~ expr}

listing = ${"new" ~ WHITESPACE_COMMENT+ ~ "Listing" ~ WHITESPACE_COMMENT* ~ "{" ~ WHITESPACE_COMMENT* ~ ((property|expr) ~ WHITESPACE_COMMENT*)* ~ "}"}
class_instance = ${"new" ~ WHITESPACE_COMMENT+ ~ ident ~ WHITESPACE_COMMENT* ~ "{" ~ WHITESPACE_COMMENT* ~ ((class_type_field|property) ~ WHITESPACE_COMMENT*)* ~ "}"}

function_expr_arg = { ident ~ (COLON ~ TYPE)? }
function_expr = !{"(" ~ (function_expr_arg ~ ("," ~ function_expr_arg)* ~ ","?)* ~ ")" ~ "->" ~ expr}

fn_call = !{ ident ~ "(" ~ (expr ~ ("," ~ expr)* ~ ","?)? ~ ")"}

// operations
infix  = _{ add | sub | mul | div | div_r | pow | modulo | comp_equal | comp_greater | comp_greater_equal | comp_less | comp_less_equal | null_coalescing  }
prefix = _{ neg | logical_not }
postfix = { non_null }

type_op = {is_op | as_op}

non_null = { "!!" } // non null operator
neg    =  { "-" } // Negation

add    =   { "+"  } // Addition
sub    =   { "-"  } // Subtraction
mul    =   { "*"  } // Multiplication
div    =   { "/"  } // Division
div_r  =   { "~/" } // Division rounded
pow    =   { "**" } // Exponentiation
modulo =   { "%"  } // Modulo

comp_equal         = { "==" }
comp_greater       = { ">" }
comp_greater_equal = { ">=" }
comp_less          = { "<" }
comp_less_equal    = { "<=" }

is_op     =   { "is" }
as_op     =   { "as" }

logical_not = {"!"}
null_coalescing = { "??" }



ident_with_start_symbol = { ("_" | "$") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")+ }
ident_without_start_symbol = { ASCII_ALPHA+ ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }
basic_ident = @{ ident_without_start_symbol | ident_with_start_symbol }
illegal_ident = { "`" ~ (!"`" ~ ANY)+ ~ "`" }
// blank_ident = { _ }
ident = @{ basic_ident | illegal_ident }


dot_expr = { (non_null | parenthesized | class_instance | value | fn_call | index_expr | ident | amended_object) ~ ("." ~ (fn_call | index_expr | ident))+ }
// index_expr => listing[index]
index_expr = !{ (non_null | parenthesized | listing | value | fn_call | ident) ~ "[" ~ expr ~ "]" }

value = { bool | null | float | int | string }

null = _{ "null" }
bool = @{ "true" | "false" }

// Strings
unicode_digits = @{  ASCII_HEX_DIGIT{1, 6}  }
escape_sequences = {"\\t" | "\\n" | "\\r" | "\\\"" | "\\\\" | ("\\u" ~ "{" ~ unicode_digits ~ "}") }

interpolation = !{ "\\(" ~ expr ~ ")" }

basic_string_true_content = { (!"\"" ~ (interpolation | escape_sequences | ANY))* }
basic_string = ${"\"" ~ basic_string_true_content ~ "\""}


multiline_content = { (!multiline_end ~ (interpolation | escape_sequences | ANY))* }
multiline_end = { "\n" ~ SPACE* ~ "\"\"\"" }
multiline_start = { "\"\"\"" ~ SPACE? ~ "\n" }
multiline_string = ${ multiline_start ~ multiline_content ~ multiline_end}

custom_escaped = @{ "\\#" | escape_sequences }
custom_string = ${
    PUSH("#"*) ~ "\""
        ~ raw_string_interior
        ~ "\"" ~ POP
}
raw_string_interior = {
    (
        !("\"" ~ PEEK)    // unless the next character is a quotation mark
                          // followed by the correct amount of number signs,
                          // consume content
        ~ (interpolation | custom_escaped | ANY)
    )*
}

string = { multiline_string | basic_string | custom_string }

// Numbers
hex_int = @{ "0x" ~ ASCII_HEX_DIGIT+ ~ ("_" ~ ASCII_HEX_DIGIT+)* }
octal_int = @{ "0o" ~ ASCII_OCT_DIGIT+ ~ ("_" ~ ASCII_OCT_DIGIT+)* }
binary_int = @{  "0b" ~ ASCII_BIN_DIGIT+ ~ ("_" ~ ASCII_BIN_DIGIT+)* }
basic_int = @ { ASCII_DIGIT+ ~ ("_" ~ ASCII_DIGIT+)* }
int = { hex_int | octal_int | binary_int | basic_int }

exponent = { ("e" | "E") ~ ("+" | "-")? ~ basic_int+ }
float = @{ "NaN" | ("Infinity" | (basic_int? ~ "." ~ basic_int+ ~ exponent? ))}

// do we need to enforce the
// input of a newline after a prop here ?
obj_fields = { property* }
object = !{ "{" ~ obj_fields? ~ "}" }

amended_object = { "(" ~ ident ~ ")" ~ WHITESPACE* ~ object }

// ********
//  *****
//  stmts
//  *****
// ********

// a stmt with an annotation
annotation = {"@" ~ ident ~ "{" ~ (ident ~ EQUAL ~ expr)* ~ "}"}
with_annotation = { annotation ~ stmt }

// a stmt with a doc comment
doc_comment = @{ "///" ~ (!("\n"~!(SPACE*~"///")) ~ ANY)* }
with_doc_comment = { doc_comment ~ stmt }

property_keyword = @{"local" | "fixed" | "const" | "external"}
property = ${ (property_keyword ~ WHITESPACE_COMMENT+)* ~ ident ~ WHITESPACE_COMMENT* ~ (object | ((COLON ~ WHITESPACE_COMMENT* ~ TYPE)? ~ EQUAL ~ WHITESPACE_COMMENT* ~ expr) | (COLON ~ WHITESPACE_COMMENT* ~ TYPE))}

typealias_params = !{WHITESPACE* ~ ident ~ ("," ~ ident)* ~ WHITESPACE* }
typealias = ${ "typealias" ~ WHITESPACE_COMMENT+  ~ ident ~ ("<" ~ typealias_params ~ ">")? ~ EQUAL ~ WHITESPACE_COMMENT* ~ TYPE }

module_keyword = @{ ("open" ~ WHITESPACE_COMMENT+)? ~ "module"}
module_src = {ident ~ ("." ~ ident)*}
module = ${ module_keyword ~ WHITESPACE_COMMENT+ ~ module_src }

src = {"\"" ~ (!"\"" ~ ANY)+ ~ "\""}

amends = ${ "amends" ~ WHITESPACE_COMMENT+ ~ src}
extends = ${ "extends" ~ WHITESPACE_COMMENT+ ~ src}

import_as = {ident}
import = ${ "import" ~ WHITESPACE_COMMENT+ ~ src ~ (WHITESPACE_COMMENT+ ~ "as" ~ WHITESPACE_COMMENT+ ~ import_as)? }

fn_keyword = @{"local" | "const" | "external"}
arg = !{ ident ~ COLON ~ TYPE }
function_args = !{ WHITESPACE_COMMENT* ~ arg ~ ("," ~ arg)* ~ ("," ~ WHITESPACE_COMMENT*)? }
return_type_annotation = !{COLON ~ TYPE}
function_name = {ident}
function = ${ (fn_keyword ~ WHITESPACE_COMMENT+)* ~ "function" ~ WHITESPACE_COMMENT+ ~ function_name ~ WHITESPACE_COMMENT* ~ (type_attribute ~ WHITESPACE_COMMENT*)? ~ "(" ~ function_args? ~  ")" ~ ((return_type_annotation? ~ EQUAL ~ WHITESPACE_COMMENT* ~ expr)|return_type_annotation) }

out_type = ${"out" ~ WHITESPACE_COMMENT+ ~ TYPE}
class_attribute = {"<" ~ out_type ~ ("," ~ out_type)* ~ ">"}

class_kind = @{"local" | "const" | "external" | "abstract" | "open"}
class_field_keyword = @{"local" | "hidden" | "const"}
class_extends = ${"extends" ~ WHITESPACE_COMMENT+ ~ ident }
class_type_field = ${ (class_field_keyword ~ WHITESPACE_COMMENT+)* ~ ident ~ COLON ~ WHITESPACE_COMMENT* ~ TYPE }
class_field_with_annotation = !{annotation ~ (class_type_field|property|function)}
class_field_with_doc_comment = !{doc_comment ~ (class_type_field|property|function)}
class_body = !{ (class_field_with_annotation|class_field_with_doc_comment|class_type_field|property|function)* }
class = ${(class_kind ~ WHITESPACE_COMMENT+)* ~ "class" ~ WHITESPACE_COMMENT+ ~ ident ~ class_attribute? ~ (WHITESPACE_COMMENT+ ~ class_extends)? ~ (WHITESPACE_COMMENT* ~ "{" ~ WHITESPACE_COMMENT* ~ class_body ~ WHITESPACE_COMMENT* ~ "}")?}

// ********
//  *****
//  types
//  *****
// ********

// do not use 'type' cause it's a rust keyword
TYPE = !{ (union | basic_type | string | function_type) ~ nullable? }
nullable = _{"?"}

basic_type = {type_with_restraints | type_with_attr | ident}
type_attribute = {"<" ~ TYPE ~ ("," ~ TYPE)* ~ ">"}
type_with_attr = !{ ident ~ type_attribute }
type_with_restraints = !{ (type_with_attr | ident) ~ "(" ~ expr ~ ")"}

function_type = !{"(" ~ (TYPE ~ ("," ~ TYPE)* ~ ","?)* ~ ")" ~ "->" ~ TYPE}

union_member = {(basic_type | string | function_type) ~ nullable?}
union = !{ union_member ~ ("|" ~ union_member)+}
